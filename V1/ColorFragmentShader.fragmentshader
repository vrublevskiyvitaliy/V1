#version 120

// Interpolated values from the vertex shaders
//varying vec3 fragmentColor;
//
//void main(){
//
//	// Output color = color specified in the vertex shader,
//	// interpolated between all 3 surrounding vertices
//	gl_FragColor = vec4(fragmentColor, 1);
//
//}
//uniform float rand;
varying vec3 vsoPosition;

void main(void) {
    int i, c=0;
    
    vec3 cellPoints[100];
    cellPoints[0] = vec3(-1.0f, -1.0f, 0.0f);
    cellPoints[1] = vec3(1.0f, -1.0f, 0.0f);
    cellPoints[2] = vec3(0.0f,  1.0f, 0.0f);
    cellPoints[3] = vec3(1.0f,  1.0f, 0.0f);
    cellPoints[4] = vec3(0.0f,  0.0f, 0.0f);
    cellPoints[5] = vec3(0.3f,  -0.5f, 0.0f);
    cellPoints[6] = vec3(0.1f,  0.2f, 0.0f);
    cellPoints[7] = vec3(0.0f,  -0.3f, 0.0f);
    cellPoints[8] = vec3(0.0f,  0.8f, 0.0f);
    cellPoints[9] = vec3(-0.3f,  0.1f, 0.0f);
    cellPoints[10] = vec3(-2.0f,  -0.9f, 0.0f);
    
    float min = length(cellPoints[0] - vsoPosition), l;
    for(i = 1; i < 11; i++){
        l = length(vsoPosition - cellPoints[i]);
        if (l < min){ min = l; c = i;}
    }
    //fragColor = vec4(vec3(0.95, 0.3, 0.3) + vec3(1.0, 1.0, 0.0) * (min)*2, 1.0);
    //min = 1;
    //gl_FragColor = vec4(vec3(0.95, 0.3, 0.3) + vec3(1.0, 1.0, 0.0) * (min)*2, 1.0);
    // gl_FragColor = vec4(vec3(0.1, 0.1, 0.1)* (c)*2, 1.0);
    //gl_FragColor = vec4(vec3(length(vsoPosition - cell[3])), 1.0);
    gl_FragColor = length(min) > 0.01 ? vec4(vec3(1.0f/(c+1)), 1.0) : vec4(1.,0,0, 1.0);
    
    
    
    //gl_FragColor = vec4(vsoPosition, 1.0);
}
